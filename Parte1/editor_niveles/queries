1.
:param lootName=>"Arrows"

MATCH (l:Loot {name: $lootName})-[:CONTAINS]-(r:Room)
RETURN r.room_name

2.
:param roomId=>10486;

MATCH p=(m:Monster)-[:CONTAINS]-(r:Room {room_id: $roomId})
RETURN DISTINCT m.name

3.
MATCH (m:Monster)
WHERE NOT (m)-[:CONTAINS]-(:Room)
RETURN m

4.
MATCH (ini: Area {name: "Panicky Desert of Fomalhaut"})
MATCH (end: Area {name: "Empowered Steppe of Isengard"})
CALL apoc.algo.dijkstra(ini, end, "IS_CONNECTED", "weight", 1)
YIELD path, weight
RETURN path, weight AS total_weight

5.
MATCH (ini: Area {name: "Panicky Desert of Fomalhaut"})
MATCH (end: Area {name: "Empowered Steppe of Isengard"})
CALL apoc.algo.dijkstra(ini, end, "IS_CONNECTED>", "weight", 1)
YIELD path, weight
UNWIND nodes(path) AS node
MATCH (node)-[:CONTAINS]->(monster:Monster)
RETURN DISTINCT monster.name AS MonstersToDefeat

6.
MATCH (start:Area), (end:Area)
WHERE start <> end
CALL apoc.algo.dijkstra(start, end, 'IS_CONNECTED>', 'weight', 1) YIELD path, weight
WITH start, end, nodes(path) AS roomNodes, weight as pathLength
WHERE all(node in roomNodes[1..-2] WHERE node:Room)
CREATE (start)-[r:SHORTEST_PATH_TO]->(end)
SET r.distance = pathLength
RETURN start.name AS StartArea, end.name AS EndArea, roomNodes AS ShortestPath, pathLength AS PathLength


7.

MATCH (a1:Area)-[i1:IS_CONNECTED]->(r1:Room)
MATCH (a2:Area)<-[i2:IS_CONNECTED]-(r2:Room)
WHERE i1.dungeon_name = i2.dungeon_name 
CREATE (a1)-[r:PATH {dungeon_name: i1.dungeon_name}]->(a2)
RETURN a1,a2,r

8.
MATCH (:Area)-[i:IS_CONNECTED]->(:Room)
WITH DISTINCT i.dungeon_name AS dungeonName

CALL apoc.cypher.doIt("
    MATCH (a1:Area)-[i:IS_CONNECTED]->(startRoom:Room)
    WHERE i.dungeon_name = $dungeonName
    CALL apoc.path.subgraphNodes(startRoom, {
        relationshipFilter: 'IS_CONNECTED',
        labelFilter: 'Room'
    }) YIELD node
    SET node.dungeon_name = $dungeonName
    RETURN count(node) AS updatedRooms
", {dungeonName: dungeonName}) YIELD value

RETURN dungeonName, value.updatedRooms AS UpdatedRoomCount


---- Todos los nodos de esta mazmorra

MATCH (a1:Area)-[i:IS_CONNECTED]->(startRoom:Room)
MATCH (a2:Area)<-[i2:IS_CONNECTED]-(endRoom:Room)
WHERE i.dungeon_name="Fenglass, Sepulcher of the Terrible Emperors" AND i2.dungeon_name = "Fenglass, Sepulcher of the Terrible Emperors"
CALL apoc.path.subgraphNodes(startRoom, {
    relationshipFilter: "IS_CONNECTED",
    labelFilter: "Room"
}) YIELD node
RETURN node, a1, a2